// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'card_type_case.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$CardTypeCaseTearOff {
  const _$CardTypeCaseTearOff();

// ignore: unused_element
  _Front front() {
    return const _Front();
  }

// ignore: unused_element
  _Back back() {
    return const _Back();
  }

// ignore: unused_element
  _Me me() {
    return const _Me();
  }
}

/// @nodoc
// ignore: unused_element
const $CardTypeCase = _$CardTypeCaseTearOff();

/// @nodoc
mixin _$CardTypeCase {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult front(),
    @required TResult back(),
    @required TResult me(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult front(),
    TResult back(),
    TResult me(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult front(_Front value),
    @required TResult back(_Back value),
    @required TResult me(_Me value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult front(_Front value),
    TResult back(_Back value),
    TResult me(_Me value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $CardTypeCaseCopyWith<$Res> {
  factory $CardTypeCaseCopyWith(
          CardTypeCase value, $Res Function(CardTypeCase) then) =
      _$CardTypeCaseCopyWithImpl<$Res>;
}

/// @nodoc
class _$CardTypeCaseCopyWithImpl<$Res> implements $CardTypeCaseCopyWith<$Res> {
  _$CardTypeCaseCopyWithImpl(this._value, this._then);

  final CardTypeCase _value;
  // ignore: unused_field
  final $Res Function(CardTypeCase) _then;
}

/// @nodoc
abstract class _$FrontCopyWith<$Res> {
  factory _$FrontCopyWith(_Front value, $Res Function(_Front) then) =
      __$FrontCopyWithImpl<$Res>;
}

/// @nodoc
class __$FrontCopyWithImpl<$Res> extends _$CardTypeCaseCopyWithImpl<$Res>
    implements _$FrontCopyWith<$Res> {
  __$FrontCopyWithImpl(_Front _value, $Res Function(_Front) _then)
      : super(_value, (v) => _then(v as _Front));

  @override
  _Front get _value => super._value as _Front;
}

/// @nodoc
class _$_Front implements _Front {
  const _$_Front();

  @override
  String toString() {
    return 'CardTypeCase.front()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Front);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult front(),
    @required TResult back(),
    @required TResult me(),
  }) {
    assert(front != null);
    assert(back != null);
    assert(me != null);
    return front();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult front(),
    TResult back(),
    TResult me(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (front != null) {
      return front();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult front(_Front value),
    @required TResult back(_Back value),
    @required TResult me(_Me value),
  }) {
    assert(front != null);
    assert(back != null);
    assert(me != null);
    return front(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult front(_Front value),
    TResult back(_Back value),
    TResult me(_Me value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (front != null) {
      return front(this);
    }
    return orElse();
  }
}

abstract class _Front implements CardTypeCase {
  const factory _Front() = _$_Front;
}

/// @nodoc
abstract class _$BackCopyWith<$Res> {
  factory _$BackCopyWith(_Back value, $Res Function(_Back) then) =
      __$BackCopyWithImpl<$Res>;
}

/// @nodoc
class __$BackCopyWithImpl<$Res> extends _$CardTypeCaseCopyWithImpl<$Res>
    implements _$BackCopyWith<$Res> {
  __$BackCopyWithImpl(_Back _value, $Res Function(_Back) _then)
      : super(_value, (v) => _then(v as _Back));

  @override
  _Back get _value => super._value as _Back;
}

/// @nodoc
class _$_Back implements _Back {
  const _$_Back();

  @override
  String toString() {
    return 'CardTypeCase.back()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Back);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult front(),
    @required TResult back(),
    @required TResult me(),
  }) {
    assert(front != null);
    assert(back != null);
    assert(me != null);
    return back();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult front(),
    TResult back(),
    TResult me(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (back != null) {
      return back();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult front(_Front value),
    @required TResult back(_Back value),
    @required TResult me(_Me value),
  }) {
    assert(front != null);
    assert(back != null);
    assert(me != null);
    return back(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult front(_Front value),
    TResult back(_Back value),
    TResult me(_Me value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (back != null) {
      return back(this);
    }
    return orElse();
  }
}

abstract class _Back implements CardTypeCase {
  const factory _Back() = _$_Back;
}

/// @nodoc
abstract class _$MeCopyWith<$Res> {
  factory _$MeCopyWith(_Me value, $Res Function(_Me) then) =
      __$MeCopyWithImpl<$Res>;
}

/// @nodoc
class __$MeCopyWithImpl<$Res> extends _$CardTypeCaseCopyWithImpl<$Res>
    implements _$MeCopyWith<$Res> {
  __$MeCopyWithImpl(_Me _value, $Res Function(_Me) _then)
      : super(_value, (v) => _then(v as _Me));

  @override
  _Me get _value => super._value as _Me;
}

/// @nodoc
class _$_Me implements _Me {
  const _$_Me();

  @override
  String toString() {
    return 'CardTypeCase.me()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Me);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult front(),
    @required TResult back(),
    @required TResult me(),
  }) {
    assert(front != null);
    assert(back != null);
    assert(me != null);
    return me();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult front(),
    TResult back(),
    TResult me(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (me != null) {
      return me();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult front(_Front value),
    @required TResult back(_Back value),
    @required TResult me(_Me value),
  }) {
    assert(front != null);
    assert(back != null);
    assert(me != null);
    return me(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult front(_Front value),
    TResult back(_Back value),
    TResult me(_Me value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (me != null) {
      return me(this);
    }
    return orElse();
  }
}

abstract class _Me implements CardTypeCase {
  const factory _Me() = _$_Me;
}
